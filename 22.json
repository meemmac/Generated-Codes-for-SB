{
"title": "Segment Tree",
"subtitle": "Efficient range queries and updates on arrays",
"time_complexity": "O(log N) per query/update",
"space_complexity": "O(2N)",
"category": "Data Structure",
"code": [
    "class SegmentTree:",
    "    def __init__(self, data):",
    "        self.n = len(data)",
    "        self.tree = [0] * (2 * self.n)",
    "        for i in range(self.n):",
    "            self.tree[self.n + i] = data[i]",
    "        for i in range(self.n - 1, 0, -1):",
    "            self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1]",
    "",
    "    def update(self, index, value):",
    "        pos = index + self.n",
    "        self.tree[pos] = value",
    "        while pos > 1:",
    "            pos //= 2",
    "            self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1]",
    "",
    "    def query(self, left, right):",
    "        res = 0",
    "        left += self.n",
    "        right += self.n",
    "        while left < right:",
    "            if left % 2:",
    "                res += self.tree[left]",
    "                left += 1",
    "            if right % 2:",
    "                right -= 1",
    "                res += self.tree[right]",
    "            left //= 2",
    "            right //= 2",
    "        return res"
],
"additional_information": "Segment trees allow efficient queries like sum, min, max, or GCD over any subarray interval with logarithmic time complexity."
}
