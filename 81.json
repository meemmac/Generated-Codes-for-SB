{
"title": "Binary Lifting (LCA computation)",
"subtitle": "Preprocess tree to answer Lowest Common Ancestor queries in O(log N)",
"time_complexity": "O(N log N) preprocessing, O(log N) per query",
"space_complexity": "O(N log N)",
"category": "Trees / LCA",
"code": [
    "import math",
    "def preprocess_lca(tree, root):",
    "    n = len(tree)",
    "    LOG = math.ceil(math.log2(n))",
    "    up = [[-1]*LOG for _ in range(n)]",
    "    depth = [0]*n",
    "    def dfs(u, parent):",
    "        up[u][0] = parent",
    "        for i in range(1, LOG):",
    "            if up[u][i-1] != -1:",
    "                up[u][i] = up[up[u][i-1]][i-1]",
    "        for v in tree[u]:",
    "            if v != parent:",
    "                depth[v] = depth[u] + 1",
    "                dfs(v, u)",
    "    dfs(root, -1)",
    "    return up, depth",
    "",
    "def lca(u, v, up, depth):",
    "    if depth[u] < depth[v]:",
    "        u, v = v, u",
    "    LOG = len(up[0])",
    "    for i in reversed(range(LOG)):",
    "        if up[u][i] != -1 and depth[up[u][i]] >= depth[v]:",
    "            u = up[u][i]",
    "    if u == v:",
    "        return u",
    "    for i in reversed(range(LOG)):",
    "        if up[u][i] != -1 and up[u][i] != up[v][i]:",
    "            u = up[u][i]",
    "            v = up[v][i]",
    "    return up[u][0]"
],
"additional_information": "Binary Lifting precomputes ancestors of each node at powers of two distance. Useful for fast LCA queries on trees."
}
