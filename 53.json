{
"title": "Suffix Automaton",
"subtitle": "Build compact automaton representing all substrings of a string",
"time_complexity": "O(n)",
"space_complexity": "O(n)",
"category": "String Algorithms / Automata",
"code": [
    "def build_suffix_automaton(s):",
    "    sa = [{'next': {}, 'link': -1, 'len': 0}]",
    "    last = 0",
    "    for ch in s:",
    "        cur = len(sa)",
    "        sa.append({'next': {}, 'link': 0, 'len': sa[last]['len'] + 1})",
    "        p = last",
    "        while p != -1 and ch not in sa[p]['next']:",
    "            sa[p]['next'][ch] = cur",
    "            p = sa[p]['link']",
    "        if p == -1:",
    "            sa[cur]['link'] = 0",
    "        else:",
    "            q = sa[p]['next'][ch]",
    "            if sa[p]['len'] + 1 == sa[q]['len']:",
    "                sa[cur]['link'] = q",
    "            else:",
    "                clone = len(sa)",
    "                sa.append({'next': sa[q]['next'].copy(), 'link': sa[q]['link'], 'len': sa[p]['len'] + 1})",
    "                while p != -1 and sa[p]['next'].get(ch) == q:",
    "                    sa[p]['next'][ch] = clone",
    "                    p = sa[p]['link']",
    "                sa[q]['link'] = sa[cur]['link'] = clone",
    "        last = cur",
    "    return sa"
],
"additional_information": "Suffix automaton compactly stores all substrings; useful for counting distinct substrings, longest common substring queries, etc."
}
