{
"title": "Push–Relabel (Highest Label) Max Flow",
"subtitle": "Efficient max-flow algorithm often faster in practice for dense graphs",
"time_complexity": "O(V^3) worst-case, typically faster in practice",
"space_complexity": "O(V + E)",
"category": "Graph Theory / Network Flow",
"code": [
    "from collections import deque",
    "def push_relabel(n, capacity, s, t):",
    "    # capacity as adjacency matrix or dict-of-dicts; here matrix",
    "    flow = [[0]*n for _ in range(n)]",
    "    excess = [0]*n",
    "    height = [0]*n",
    "    seen = [0]*n",
    "    height[s] = n",
    "    for v in range(n):",
    "        flow[s][v] = capacity[s][v]",
    "        flow[v][s] = -flow[s][v]",
    "        excess[v] = capacity[s][v]",
    "    excess[s] = -sum(capacity[s])",
    "    # list of active vertices (excluding s and t)",
    "    active = deque([i for i in range(n) if i != s and i != t and excess[i] > 0])",
    "    def push(u, v):",
    "        amt = min(excess[u], capacity[u][v] - flow[u][v])",
    "        if amt <= 0 or height[u] != height[v] + 1:",
    "            return False",
    "        flow[u][v] += amt",
    "        flow[v][u] -= amt",
    "        excess[u] -= amt",
    "        excess[v] += amt",
    "        return True",
    "    def relabel(u):",
    "        min_height = float('inf')",
    "        for v in range(n):",
    "            if capacity[u][v] - flow[u][v] > 0:",
    "                min_height = min(min_height, height[v])",
    "        if min_height < float('inf'):",
    "            height[u] = min_height + 1",
    "    while active:",
    "        u = active[0]",
    "        pushed = False",
    "        for v in range(seen[u], n):",
    "            if push(u, v):",
    "                pushed = True",
    "                if v != s and v != t and excess[v] == amt:",
    "                    active.append(v)",
    "                break",
    "            seen[u] += 1",
    "        if not pushed:",
    "            relabel(u)",
    "            seen[u] = 0",
    "        if excess[u] == 0:",
    "            active.popleft()",
    "    return sum(flow[s][i] for i in range(n))"
],
"additional_information": "Push–relabel maintains a preflow and adjusts node heights to push excess to the sink; many practical optimizations exist (gap, highest-label)."
}
